package main

import (
	"bytes"
	"io"
	"os"
	"text/template"
	"github.com/simpleapps-eu/translate/dotstrings"
)

func formatFile(fromName, toName string) (buf *bytes.Buffer, err error) {
	fromFile, err := os.Open(fromName)
	if err != nil {
		return
	}
	defer fromFile.Close()

	if fromName == toName {
		// Change in-place, use memory based buffer.
		buf = &bytes.Buffer{}
		err = format(fromFile, buf)
		return
	}

	// Change between files
	toFile, err := os.Create(toName)
	if err != nil {
		return
	}
	defer toFile.Close()

	err = format(fromFile, toFile)
	return
}

func format(fromFile io.Reader, toFile io.Writer) (err error) {

	const messageTpl = "/* {{.Ctx}} */\n\"{{.ID}}\" = \"{{.Str}}\";\n\n"
	tpl := template.Must(template.New("strings").Parse(messageTpl))

	toWriter := dotstrings.NewWriterUTF16(toFile)
	msgChan, errChan := dotstrings.LoadMessages(dotstrings.NewReaderUTF16(fromFile))
	for m := range msgChan {
		if m.Ctx == "No comment provided by engineer." {
			// Situation 1.
			//
			// NSLocalizableString(key,comment) entry in source has key set
			// but comment is an empty string.
			// e.g. NSLocalizableString(@"Loading...",@"")
			//
			// Entry as generated by genstrings:
			//
			// 	/* No comment provided by engineer. */
			// 	"Loading..." = "Loading...";
			//
			// We'll change that into:
			//
			// 	/* Loading... */
			// 	"Loading..." = "Loading...";
			//
			m.Ctx = m.Str
		} else {
			if m.ID == m.Str {
				// Situation 2.
				//
				// NSLocalizableString(key,comment) entry in source has key that contains
				// an id and the comment contains the text to translate (context).
				// e.g. NSLocalizableString(@"message_could_not_reach_desktop",@"Could not reach the Desktop.")
				//
				// Entry as generated by genstrings:
				//
				// 	/* Could not reach the Desktop. */
				// 	"message_could_not_reach_desktop" = "message_could_not_reach_desktop";
				//
				// we'll change that into
				//
				// 	/* Could not reach the Desktop. */
				// 	"message_could_not_reach_desktop" = "Could not reach the Desktop.";
				//
				m.Str = m.Ctx
			}
		}
		tpl.Execute(toWriter, m)
	}
	err, _ = <-errChan
	return
}
