package main

import (
	"flag"
	"fmt"
	"os"
)

var (
	doMove   bool
	fromName string
	toName   string
)

func init() {
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage of %s:\n\n", os.Args[0])
		fmt.Fprintln(os.Stderr, "  Makes a strings file generated by genstrings suitable to be used as a source strings file for the translation tools.")
		fmt.Fprintln(os.Stderr, "  Format the strings in the -from file and write them out to -to file.")
		fmt.Fprintln(os.Stderr, "  Use option -move to remove the -from file after -to file has been written.")
		fmt.Fprintln(os.Stderr, "")
		flag.PrintDefaults()
	}
	flag.BoolVar(&doMove, "move", false, "remove -from file when finished writing to -to file")
	flag.StringVar(&fromName, "from", "", "name of file to read strings from")
	flag.StringVar(&toName, "to", "", "name of file to write strings to")
}

func main() {
	// Use catch to recover from panics and exit program with exitcode
	defer catch()

	flag.Parse()

	if (flag.NArg() != 1) && (doMove || flag.NFlag() != 2) && (!doMove || flag.NFlag() != 3) {
		flag.Usage()
		panic(1) // silent exit
	}

	if flag.NArg() == 1 {
		fromName = flag.Arg(0)
		toName = flag.Arg(0)
	}

	buf, err := formatFile(fromName, toName)
	if err != nil {
		panic(err)
	}

	// Need to write the buffer back to the file?
	if buf != nil {
		toFile, err := os.Create(toName)
		if err != nil {
			return
		}
		defer toFile.Close()

		buf.WriteTo(toFile)
	}

	if doMove {
		err = os.Remove(fromName)
		if err != nil {
			panic(err)
		}
	}
}

func catch() {
	if err := recover(); err != nil {
		switch e := err.(type) {
		case error:
			println(e.Error())
			os.Exit(1)
		case int:
			os.Exit(e)
		default:
			panic(err)
		}
	}
}
